<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-04-30">
<meta name="description" content="Detailed exploration of Hamiltonian Monte Carlo following Neal and Betancourt. Covers typical set geometry, gradient-based smooth exploration, leapfrog integration, and the No-U-Turn Sampler (NUTS) algorithm.">

<title>Exploring Hamiltonian Monte Carlo – rahuldave</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c67a7d068a8370113d9027fc4e8bf30e.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-e0d64750a3675fa668af59a9862b8111.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c67a7d068a8370113d9027fc4e8bf30e.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d2fef15c612ec386ae0907ffd6f4ccdb.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-a009389674a9596cea61ac77c12264b2.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-d2fef15c612ec386ae0907ffd6f4ccdb.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- Google Fonts: Bitter (headings) + Source Serif 4 (body) + IBM Plex Mono (code) -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Bitter:wght@400;500;600;700&amp;family=Source+Serif+4:opsz,wght@8..60,400;8..60,500;8..60,600&amp;family=IBM+Plex+Mono:wght@400;500;600&amp;display=swap" rel="stylesheet">

<!-- Bootstrap Icons for brand mark and UI elements -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Exploring Hamiltonian Monte Carlo – rahuldave">
<meta property="og:description" content="Detailed exploration of Hamiltonian Monte Carlo following Neal and Betancourt. Covers typical set geometry, gradient-based smooth exploration, leapfrog integration, and the No-U-Turn Sampler (NUTS) algorithm.">
<meta property="og:image" content="https://rahuldave.github.io/posts/hmcexplore/index_files/figure-html/cell-3-output-1.png">
<meta property="og:site_name" content="rahuldave">
<meta property="og:image:height" content="258">
<meta property="og:image:width" content="378">
<meta name="twitter:title" content="Exploring Hamiltonian Monte Carlo – rahuldave">
<meta name="twitter:description" content="Detailed exploration of Hamiltonian Monte Carlo following Neal and Betancourt. Covers typical set geometry, gradient-based smooth exploration, leapfrog integration, and the No-U-Turn Sampler (NUTS) algorithm.">
<meta name="twitter:image" content="https://rahuldave.github.io/posts/hmcexplore/index_files/figure-html/cell-3-output-1.png">
<meta name="twitter:creator" content="@rahuldave">
<meta name="twitter:image-height" content="258">
<meta name="twitter:image-width" content="378">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">rahuldave</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../til.html"> 
<span class="menu-text">TIL</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../collections.html"> 
<span class="menu-text">Collections</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#exploring-hamiltonian-monte-carlo" id="toc-exploring-hamiltonian-monte-carlo" class="nav-link active" data-scroll-target="#exploring-hamiltonian-monte-carlo">Exploring Hamiltonian Monte Carlo</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#looking-for-the-perfect-mcmc" id="toc-looking-for-the-perfect-mcmc" class="nav-link" data-scroll-target="#looking-for-the-perfect-mcmc">Looking for the perfect MCMC?</a></li>
  <li><a href="#mechanics-to-the-rescue" id="toc-mechanics-to-the-rescue" class="nav-link" data-scroll-target="#mechanics-to-the-rescue">Mechanics to the rescue</a></li>
  <li><a href="#data-augmentation" id="toc-data-augmentation" class="nav-link" data-scroll-target="#data-augmentation">Data Augmentation</a></li>
  <li><a href="#hamiltonian-mechanics" id="toc-hamiltonian-mechanics" class="nav-link" data-scroll-target="#hamiltonian-mechanics">Hamiltonian Mechanics</a>
  <ul class="collapse">
  <li><a href="#an-example" id="toc-an-example" class="nav-link" data-scroll-target="#an-example">An example</a></li>
  <li><a href="#the-hamiltonian-is-conserved" id="toc-the-hamiltonian-is-conserved" class="nav-link" data-scroll-target="#the-hamiltonian-is-conserved">The Hamiltonian is conserved</a></li>
  <li><a href="#reversibility" id="toc-reversibility" class="nav-link" data-scroll-target="#reversibility">Reversibility</a></li>
  <li><a href="#volume-in-phase-space-is-conserved" id="toc-volume-in-phase-space-is-conserved" class="nav-link" data-scroll-target="#volume-in-phase-space-is-conserved">Volume in phase space is conserved</a></li>
  <li><a href="#the-microcanonical-distribution" id="toc-the-microcanonical-distribution" class="nav-link" data-scroll-target="#the-microcanonical-distribution">The microcanonical distribution</a></li>
  </ul></li>
  <li><a href="#stochasticity" id="toc-stochasticity" class="nav-link" data-scroll-target="#stochasticity">Stochasticity</a>
  <ul class="collapse">
  <li><a href="#sampling-the-momentum" id="toc-sampling-the-momentum" class="nav-link" data-scroll-target="#sampling-the-momentum">Sampling the momentum</a></li>
  </ul></li>
  <li><a href="#tuning" id="toc-tuning" class="nav-link" data-scroll-target="#tuning">Tuning</a>
  <ul class="collapse">
  <li><a href="#choice-of-kinetic-energy" id="toc-choice-of-kinetic-energy" class="nav-link" data-scroll-target="#choice-of-kinetic-energy">Choice of Kinetic Energy</a></li>
  <li><a href="#choice-of-integration-times" id="toc-choice-of-integration-times" class="nav-link" data-scroll-target="#choice-of-integration-times">Choice of integration times</a></li>
  </ul></li>
  <li><a href="#simulating-hamiltonian-systems-discretization" id="toc-simulating-hamiltonian-systems-discretization" class="nav-link" data-scroll-target="#simulating-hamiltonian-systems-discretization">Simulating Hamiltonian Systems: Discretization</a>
  <ul class="collapse">
  <li><a href="#euler-discretization" id="toc-euler-discretization" class="nav-link" data-scroll-target="#euler-discretization">Euler Discretization</a></li>
  <li><a href="#being-symplectic-the-leapfrog-method" id="toc-being-symplectic-the-leapfrog-method" class="nav-link" data-scroll-target="#being-symplectic-the-leapfrog-method">Being symplectic: the Leapfrog method</a></li>
  <li><a href="#the-acceptance-probability" id="toc-the-acceptance-probability" class="nav-link" data-scroll-target="#the-acceptance-probability">The Acceptance Probability</a></li>
  </ul></li>
  <li><a href="#the-hmc-algorithm" id="toc-the-hmc-algorithm" class="nav-link" data-scroll-target="#the-hmc-algorithm">The HMC Algorithm</a>
  <ul class="collapse">
  <li><a href="#a-simple-implementation" id="toc-a-simple-implementation" class="nav-link" data-scroll-target="#a-simple-implementation">A simple implementation</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<!-- Theme toggle persistence script -->
<script>
(function() {
  // Check for saved theme preference, otherwise use system preference
  const savedTheme = localStorage.getItem('quarto-color-scheme');
  if (savedTheme) {
    document.documentElement.setAttribute('data-bs-theme', savedTheme);
  }

  // Listen for theme changes (Quarto's built-in toggle) and persist
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.attributeName === 'data-bs-theme') {
        const currentTheme = document.documentElement.getAttribute('data-bs-theme');
        if (currentTheme) {
          localStorage.setItem('quarto-color-scheme', currentTheme);
        }
      }
    });
  });

  // Start observing once DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      observer.observe(document.documentElement, { attributes: true });
    });
  } else {
    observer.observe(document.documentElement, { attributes: true });
  }
})();
</script>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Exploring Hamiltonian Monte Carlo</h1>
<p class="subtitle lead">From typical sets to leapfrog integration: a detailed exploration of HMC and NUTS.</p>
  <div class="quarto-categories">
    <div class="quarto-category">mcmc</div>
    <div class="quarto-category">sampling</div>
    <div class="quarto-category">optimization</div>
  </div>
  </div>

<div>
  <div class="description">
    Detailed exploration of Hamiltonian Monte Carlo following Neal and Betancourt. Covers typical set geometry, gradient-based smooth exploration, leapfrog integration, and the No-U-Turn Sampler (NUTS) algorithm.
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 30, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="exploring-hamiltonian-monte-carlo" class="level1">
<h1>Exploring Hamiltonian Monte Carlo</h1>
<section id="keywords-hamiltonian-monte-carlo-energy-nuts-leapfrog-canonical-distribution-microcanonical-distribution-transition-distribution-marginal-energy-distribution-data-augmentation-classical-mechanics-detailed-balance-statistical-mechanics" class="level5">
<h5 class="anchored" data-anchor-id="keywords-hamiltonian-monte-carlo-energy-nuts-leapfrog-canonical-distribution-microcanonical-distribution-transition-distribution-marginal-energy-distribution-data-augmentation-classical-mechanics-detailed-balance-statistical-mechanics">Keywords: hamiltonian monte carlo, energy, NUTS, leapfrog, canonical distribution, microcanonical distribution, transition distribution, marginal energy distribution, data augmentation, classical mechanics, detailed balance, statistical mechanics</h5>
<div id="cell-2" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>pd.set_option(<span class="st">'display.width'</span>, <span class="dv">500</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>pd.set_option(<span class="st">'display.max_columns'</span>, <span class="dv">100</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.core.display <span class="im">import</span> Image</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pymc3 <span class="im">as</span> pm</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>A lot of HMC’s recent appreciation as an MCMC method is due to <a href="https://arxiv.org/pdf/1206.1901.pdf">Neal</a>, and we’ll follow him and <a href="https://arxiv.org/abs/1701.02434">Betancourt</a> heavily here. All the signature Maroon diagrams are from Betancourt’s review paper.</p>
<section id="looking-for-the-perfect-mcmc" class="level2">
<h2 class="anchored" data-anchor-id="looking-for-the-perfect-mcmc">Looking for the perfect MCMC?</h2>
<p>The problem with MH is that is sensitive to the step size, Gibbs we need to know how to draw from the conditionals. What we want is the ability to adjust the step size but at the same time preserving the properties of MCMC, namely being able to sample the whole space and at the same time converge to the target distribution. We also would like to have no burnin, no autocorrelation, guarantee mixing and convergence very fast and no tunable parameters (and a pony).</p>
<p>In other words, we’d like to explore the typical-set surface smoothly. To do this we must first characterize the surface, something we can do via a gradient. To do this we must identify the equation of the typical set surface so that we can find the gradient which is perpendicular to the surface. And once we do that, we are not done, as the gradient points towards regions of higher density (modes) from the surface of the typical set.</p>
<p>To do this imagine a sliver <span class="math inline">\(dP = p(q)dq\)</span> thats in the typical set. If <span class="math inline">\(dq\)</span> (we are using <span class="math inline">\(q\)</span> instead of <span class="math inline">\(x\)</span>) is small enough, then we can consider the typical set as a collection of foliates <span class="math inline">\(\{q_i\}\)</span> each of constant probability density <span class="math inline">\(p(q)=c_i\)</span> where <span class="math inline">\(c_i\)</span> is a constant. Thus there are n such foliates, or “orbits”, or level sets. Now we know that the gradient is perpendicular to such level-sets and we can use it to characterize these sets.</p>
</section>
<section id="mechanics-to-the-rescue" class="level2">
<h2 class="anchored" data-anchor-id="mechanics-to-the-rescue">Mechanics to the rescue</h2>
<p>We can make our usual connection to the energy of a physical system by tentatively identifying the energy <span class="math inline">\(E = - log(p(q))\)</span>. This is what we did to find distributions in Metropolis and the inverse <span class="math inline">\(p(q) = e^{-E(q)/T}\)</span> the minima of functions in simulated annealing. There we proposed a move using a proposal distribution, creating a random walk.</p>
<p>We dont want to do that here, preferring something that will move us smoothly along a level set. We use our newly acquired knowledge of data-augmentation and gibbs-sampling from an augmented distribution instead.</p>
<p>But first let us make a change of purpose and notation. Lets write now the potential energy as:</p>
<p><span class="math display">\[V(q) = - log\, p(q)\]</span></p>
<p>such that</p>
<p><span class="math display">\[p(q) = e^{-V(q)}.\]</span></p>
<div id="cell-7" class="cell" data-execution_count="31">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>fun <span class="op">=</span> <span class="kw">lambda</span> q: sp.stats.norm.pdf(q) </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>qq <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">100</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>plt.plot(qq, fun(qq))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-8" class="cell" data-execution_count="33">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> <span class="kw">lambda</span> q: <span class="op">-</span>np.log(fun(q))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>plt.plot(qq, V(qq))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The basic idea is to add a <strong>momentum</strong> variable <span class="math inline">\(p\)</span> for each <span class="math inline">\(q\)</span> in our probability density, adding a kinetic energy term to the potential energy to create a total energy, and thus creating a joint pdf <span class="math inline">\(p(p,q)\)</span>.</p>
<p>How would this work? And why momentum? Lets think about a rocket (or a satellite with thrusters it can fire) in orbit around the earth</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/rocketorbit.png" class="img-fluid figure-img"></p>
<figcaption>A satellite in orbit: with the right momentum, it follows a constant-energy trajectory around the Earth, analogous to HMC traversing level sets. From Betancourt.</figcaption>
</figure>
</div>
<p>If this rocket had no velocity, it would simply fall down to the earth because it would not be able to counterbalance earth’s gravitational potential (the equivalent of the energy we formulated above and have used in simulated annealing). On the other hand, if it had too much velocity, it would escape earth’s gravity and take off to mars or similar.</p>
<p>If we add just the right amount of momentum, it will exactly counterbalance the gravitational force, and the satellite will continue to move in its orbit. And this is an orbit of minimum energy (and therefore constant energy, since a system at minumum energy wont lift from it unless kicked(perhaps stochastically) to do so). Thus the satellite will move exactly along a level-curve of the energy level, in a direction exactly perpendicular to the gradient. Such motion is called <strong>conservative</strong>, as it conserves energy. In mechanics, the conserving of energy is related to the time-independence and thus time irreversibility of motion: is there is no <em>explicit</em> dependence on time in the equations of motion (there always is implicit dependence as positions and momenta depend on time), energy is conserved.</p>
</section>
<section id="data-augmentation" class="level2">
<h2 class="anchored" data-anchor-id="data-augmentation">Data Augmentation</h2>
<p>Recall that the basic idea behind Data Augmentation is to resolve difficulty in simulate from <span class="math inline">\(p(x)\)</span> using the traditional methods by constructing a joint pdf such that:</p>
<p><span class="math display">\[ \int p(x,y)\, dy = p(x)  \]</span></p>
<p>and simulating from the associated conditional pdfs, <span class="math inline">\(p(x|y)\)</span> and <span class="math inline">\(p(y|x)\)</span> is easy.</p>
<p>The DA algorithm is based on this joint pdf, and we <em>marginalize</em> over the <strong>augmenting variable</strong> <span class="math inline">\(y\)</span> to obtain samples for <span class="math inline">\(p(x)\)</span>.</p>
<p>The simplest form of DA algorithm takes the following form:</p>
<ol type="1">
<li>Draw <span class="math inline">\(Y\sim P_{Y|X}(.|x)\)</span> and call the observed value y</li>
<li>Draw <span class="math inline">\(X_{n+1} \sim P_{X|Y}(.|y)\)</span></li>
</ol>
<p>After disregarding the <span class="math inline">\(Y_i\)</span> in our samples in making a <span class="math inline">\(X\)</span> histogram, we have samples <span class="math inline">\(X_i \sim P(x)\)</span>.</p>
<p>To achieve our goal we introduce a new variable as we did for DA and Slice Sampling we now call <span class="math inline">\(p\)</span>. As we explained in DA the new joint distribution</p>
<p><span class="math display">\[p(q) = \int p(q,p) \, dp \]</span></p>
<p>An easy way to achieve this is if <span class="math inline">\(p(q,p)=p(q)p(p \vert q)\)</span>. And since we can choose our joint distribution as we like, we choose (the reasons will be obvious soon).</p>
<p><span class="math display">\[ p(q,p) = e^{-V(q)-K(q,p)} = e^{-V(q)} e^{-p^2/2m}\]</span></p>
<p>Where <span class="math inline">\(m\)</span> is just a constant thus <span class="math inline">\(p(p)\)</span> is Gaussian. The kinetic energy if <span class="math inline">\(p\)</span> is the momentum is <span class="math inline">\(K(q, p)=p^2/2m\)</span>. This kinetic energy <span class="math inline">\(K(p,q)\)</span> has a mass parameter <span class="math inline">\(m(q)\)</span>(one can consider generalizations of the kinetic energy term from this version we have from introductory physics).</p>
<p>The choice of a kinetic energy term then is the choice of a conditional probability distribution over the “augmented” momentum which ensures that</p>
<p><span class="math display">\[\int dp p(p, q) = \int dp p(p \vert q) p(q) = p(q) \int p(p \vert q) dp = p(q).\]</span></p>
<p>Thus the key to moving a sampler along a probability level curve is to give the sampler momentum and thus kinetic energy via the augmented momemtum variable. In other words, we must carry out an augmentation with an additional momentum which leaves the energy <strong>Hamiltonian</strong></p>
<p><span class="math display">\[H(p, q) = \frac{p^2}{2m} +  V(q) = E_i,\]</span></p>
<p>and thus:</p>
<p><span class="math display">\[H(p,q) = -log(p(p,q)) = -log p(p \vert q) - log p(q)\]</span></p>
<p>with <span class="math inline">\(E_i\)</span> constants (constant energies) for each level-set foliate and where the <strong>potential energy</strong> <span class="math inline">\(V(q) = -log(p(q))\)</span> replaces the energy term we had earlier in simulated annealing.</p>
<p><strong>Thus it is critical to realize that we are now looking at level curve foliates of <span class="math inline">\(p(p,q)\)</span>, not those of <span class="math inline">\(p(q)\)</span></strong>. Our real aim is to explore the latter. This joint distribution is called the <strong>canonical distribution</strong></p>
<p>With a quadratic in <span class="math inline">\(p\)</span> and if <span class="math inline">\(V(q) = \frac{1}{2}q^2\)</span> our distribution is gaussian and the level sets are ellipses of constant energy, as illustrated below, in a space called <strong>phase space</strong>, which is constructed by plotting the co-ordinates against the momenta: that is, it is just the space in which our augmented joint-distribution lives.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/levelsets.png" class="img-fluid figure-img"></p>
<figcaption>Hamiltonian level sets in phase space: constant-energy elliptical orbits in (p,q) for a Gaussian target. From Betancourt.</figcaption>
</figure>
</div>
</section>
<section id="hamiltonian-mechanics" class="level2">
<h2 class="anchored" data-anchor-id="hamiltonian-mechanics">Hamiltonian Mechanics</h2>
<p>The game now is to sample from this two-N-dimensional distribution and marginalize over the momenta to get the distribution from the <span class="math inline">\(q\)</span>. To carry out this sampling, we’ll use the physics equations of motion in the <strong>Hamiltonian Formalism</strong> (thus leading to the name Hamiltonian Monte Carlo) to “glide” over a level set. Given a Hamiltonian H, the Hamiltonian equations of motion are as follows:</p>
<p><span class="math display">\[
\begin{eqnarray}
\frac{dp}{dt}  &amp;=&amp; -\frac {\partial H}{\partial q} \\
\frac{dq}{dt}  &amp;=&amp; \frac {\partial H}{\partial p}
\end{eqnarray}
\]</span></p>
<p>If we have</p>
<p><span class="math display">\[H=p^2/2m + V(q)\]</span></p>
<p>then <span class="math inline">\(\frac{dp}{dt} = -\frac {\partial H}{\partial q} = -\frac {\partial V}{\partial q} = Force\)</span> is newton’s law, and the other equation sats that velocity is momentum divided by mass.</p>
<section id="an-example" class="level3">
<h3 class="anchored" data-anchor-id="an-example">An example</h3>
<p>Here is an example of a harmonic oscillator with mass 1 and spring-constant 1</p>
<div id="cell-14" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>q_t <span class="op">=</span> <span class="kw">lambda</span> t: <span class="fl">4.</span> <span class="op">*</span> np.cos(t)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>p_t <span class="op">=</span> <span class="kw">lambda</span> t: <span class="op">-</span><span class="fl">4.</span> <span class="op">*</span> np.sin(t)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>H_x_r_t <span class="op">=</span> <span class="kw">lambda</span> t: q_t(t)<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="fl">2.</span> <span class="op">+</span> p_t(t)<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="fl">2.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>np.pi,<span class="dv">100</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>[<span class="dv">12</span>,<span class="dv">4</span>])</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>plt.plot(t, q_t(t), label<span class="op">=</span><span class="st">'q'</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>plt.plot(t, p_t(t), label<span class="op">=</span><span class="st">'p'</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>plt.plot(t, H_x_r_t(t), label<span class="op">=</span><span class="st">'H'</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'t'</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>plt.plot(q_t(t), p_t(t), <span class="st">'.'</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'q(t)'</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'p(t)'</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"min and max of H: "</span>, np.<span class="bu">min</span>( H_x_r_t(t)), np.<span class="bu">max</span>( H_x_r_t(t)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>min and max of H:  8.0 8.0</code></pre>
</div>
</div>
</section>
<section id="the-hamiltonian-is-conserved" class="level3">
<h3 class="anchored" data-anchor-id="the-hamiltonian-is-conserved">The Hamiltonian is conserved</h3>
<p>Notice that in the example above the Hamiltonian is conserved. While the <span class="math inline">\(q\)</span> amd <span class="math inline">\(p\)</span> have time dependencies, the <span class="math inline">\(H\)</span> does not.</p>
<p>If the Hamiltonian H doesn’t have a functional dependence on time we see that</p>
<p><span class="math display">\[ \frac{dH}{dt} = \sum_i \left[\frac {\partial H}{\partial q_i}\frac{dq_i}{dt} + \frac {\partial H}{\partial p_i}\frac{dp_i}{dt} \right] + \frac{\partial H}{\partial t} \]</span></p>
<p>Notice that I have explicitly indexed the co-ordinates and momenta to reflect the dimensionality of the prolem.</p>
<p>Substituting in the Hamiltonian equations of motion we can see: <span class="math display">\[ \frac{dH}{dt} = \sum_i \left[\frac {\partial H}{\partial q_i}\frac {\partial H}{\partial p_i} + (\frac {\partial H}{\partial p_i})(-\frac {\partial H}{\partial q_i}) \right] + \frac{\partial H}{\partial t} \]</span></p>
<p>So as long as the Hamiltonian $ H({q_i, p_i}, t)$ depends only on $ {q_i, p_i } $ then <span class="math inline">\(\frac{\partial H}{\partial t} = 0\)</span> and</p>
<p><span class="math display">\[ \frac{dH}{dt} = 0\ \]</span></p>
<p>and thus $ H(t + t) = H(t) , t $.</p>
<p>This time independence is crucial to reversibility: we cannot pick a direction of time in which this system is actually being run.</p>
</section>
<section id="reversibility" class="level3">
<h3 class="anchored" data-anchor-id="reversibility">Reversibility</h3>
<p>Consider a transformation <span class="math inline">\(T_s\)</span> from <span class="math inline">\((q,p) \to (q',p')\)</span> where the primed quantities are just the variables at a “later” time <span class="math inline">\(t' = t + s\)</span>. This mapping is 1-1 and thus has an inverse <span class="math inline">\(T_{-s}\)</span>. This can be obtained by simply negating time in Hamilton’s equations:</p>
<p><span class="math display">\[
\begin{eqnarray}
\frac{dp}{d(-t)}  &amp;=&amp; -\frac {\partial H}{\partial q} \\
\frac{dq}{d(-t)}  &amp;=&amp; \frac {\partial H}{\partial p}
\end{eqnarray}
\]</span></p>
<p>This changes the equations of motion and would not be kosher, but we can preserve the equation, by merely transforming <span class="math inline">\(p \to -p\)</span> and then</p>
<p><span class="math display">\[
\begin{eqnarray}
\frac{d(-p)}{d(-t)}  &amp;=&amp; -\frac {\partial H}{\partial q} \\
\frac{dq}{d(-t)}  &amp;=&amp; \frac {\partial H}{\partial (-p)}
\end{eqnarray}
\]</span></p>
<p>and we have the old equations back. Notice that the momentum transformation does not change the Hamiltonian as long as the kinetic energy is symmetric in <span class="math inline">\(p\)</span>.</p>
<p>In other words this is what we need is this: to reverse <span class="math inline">\(T_{s}\)</span>, flip the momentum, run Hamiltonian equations backwords in time until you get back to the original position and momentum in phase space at time t, and then flip the momentum again so it is pointing in the right direction (otherwise you would be going the wrong direction on re-running time forward…that is u want to make the tranformation which preserved the Hamiltonian equations above, twice.).</p>
<p>In our oscillator example above, <span class="math inline">\(T_{-s}\)</span> is simply a rotation by <span class="math inline">\(s\)</span> radians counterclockwise in phase space, undoing the clockwise rotation created by <span class="math inline">\(T_s\)</span>, and then fliiping the direction of rotation again.</p>
<p>This is like in the superman movie! It will be critical in crafting a reversible Metropolis-Hastings proposal soon.</p>
</section>
<section id="volume-in-phase-space-is-conserved" class="level3">
<h3 class="anchored" data-anchor-id="volume-in-phase-space-is-conserved">Volume in phase space is conserved</h3>
<p>Not only does no-explicit-time dynamics conserve the Hamiltonian, it also conserves a volume element in phase space. One can see this by If the determinant of the Jacobian of this transformation is 1, the volume is preserved.</p>
<p>The transformation <span class="math inline">\(T_{s}\)</span> for small change <span class="math inline">\(s = \delta\)</span> can be written as:</p>
<p><span class="math display">\[ T_{\delta} = \left( \begin{array}{c} q \\ p\end{array} \right) + \delta \left( \begin{array}{c} \frac{dq}{dt} \\ \frac{dp}{dt}\end{array} \right)  + O(\delta^2)\]</span></p>
<p>The jacobian of this transformation is: <span class="math display">\[
\left [
\begin{array}{c}
1 + \delta \frac{\partial^2H}{\partial q\partial p} &amp; \delta \frac{\partial^2H}{\partial p^2} \\
\delta \frac{\partial^2H}{\partial q^2} &amp;  1 - \delta \frac{\partial^2H}{\partial p\partial q}
\end{array}
\right ]
\]</span></p>
<p>and thus the determinant is</p>
<p><span class="math display">\[ 1 +  O(\delta^2).\]</span></p>
<p>Since we can compose the time transformation <span class="math inline">\(s\)</span> out of many such data, out Hamiltonian is volume preserving!</p>
<p>Thus as our system evolves, any contraction or expansion in position space must be compensated by a respective expansion or compression in momentum space.</p>
<p>As a result of this, the momenta we augment our distribution with must be <strong>dual</strong> to our pdf’s parameters, transforming in the opposite way so that phase space volumes are invariant.</p>
</section>
<section id="the-microcanonical-distribution" class="level3">
<h3 class="anchored" data-anchor-id="the-microcanonical-distribution">The microcanonical distribution</h3>
<p>We have expanded our pdf’s parameter space by auxillary momenta. We have lift our target distribution in <span class="math inline">\(q\)</span> space to a joint probability distribution on phase space called the <strong>canonical</strong> distribution. In this phase space, we can explore the joint typical set by integrating Hamiltonian equations for a time.</p>
<p>Since we will consider time-implicit Hamiltonians, these flows will be volume preserving and reversible, and indeed stick to a level surface of energy.</p>
<p>Indeed we are traveling along constant <span class="math inline">\(E\)</span> or <span class="math inline">\(p(p,q)\)</span> foliates. This allows us to consider a related distribution to the canonical distribution, the <strong>microcanonical distribution</strong> (the first term in the product below). The canonical distribution can be written as a product of this microcanonical distribution and a <strong>marginal energy distribution</strong>:</p>
<p><span class="math display">\[p(q,p) = p(\theta_E \vert E) p(E)\]</span></p>
<p>where <span class="math inline">\(\theta_E\)</span> indexes the position on the level set: ie a co-ordinate for example along the ellipses in our diagram above.</p>
<p>The microcanonical distribution thus gives us the states for a given energy (or joint probability) while the marginal tells us the probability of a given level set in the typical set itself.</p>
<p>This decomposition of the problem tells us how to explore the entire typical set. We integrate Hamilton’s equations for a while to explore the microcanonical distribution on a given level set.</p>
</section>
</section>
<section id="stochasticity" class="level2">
<h2 class="anchored" data-anchor-id="stochasticity">Stochasticity</h2>
<p>But this then leaves us with the problem of having to go from one level-set to another: after all, we wish to explore the entire typical set. We thus need to stochastically explore the marginal energy distribution to go from one level-set to the other.</p>
<section id="sampling-the-momentum" class="level3">
<h3 class="anchored" data-anchor-id="sampling-the-momentum">Sampling the momentum</h3>
<p>The idea for this once again comes from our mechanical satellite analog. Think of a rocket in a partivcular orbit firing its thrusters or letting momentum slip. It can achieve a different orbit.</p>
<p>Thus the solution to exploring the marginal distribution is simple..after exploring a given level set for a while, we resample the momentum, and off to another level-set we go, as illustrated below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/momresample.png" class="img-fluid figure-img"></p>
<figcaption>Momentum resampling in HMC: after gliding along one energy level set, resample momentum to jump to a different orbit. From Betancourt.</figcaption>
</figure>
</div>
<p>Let <span class="math inline">\(p(E \vert q)\)</span> as the transition distribution of energies induced by a momentum resampling using <span class="math inline">\(p(p \vert q) = - log\, K(p,q)\)</span> at a given position <span class="math inline">\(q\)</span>. Our efficiency of this stochastic exploration over level sets then depends on how narrow this induced distribution is with respect to the marginal energy distribution:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/lsetexp.png" class="img-fluid figure-img"></p>
<figcaption>Energy distributions: the marginal energy pi(E) versus the microcanonical distribution pi(E|q). Good sampling requires their overlap. From Betancourt.</figcaption>
</figure>
</div>
<p>If the transition distribution is narrow compared to the marginal energy distribution, then the random walk amongst level sets will proceed slowly. But if it matches the marginal energy distribution, we will generate nearly independent samples from the marginal energy distribution very efficiently.</p>
<p>Thus we will draw <span class="math inline">\(p\)</span> from a distribution that is determined by the distribution of momentum, i.e.&nbsp;<span class="math inline">\(p \sim  N(0,\sqrt{M})\)</span> for example, and attempt to explore the level sets.</p>
</section>
</section>
<section id="tuning" class="level2">
<h2 class="anchored" data-anchor-id="tuning">Tuning</h2>
<p>It should be clear now that HMC needs to be tuned in at-least two ways:</p>
<ul>
<li>what is our choice of kinetic energy and how does this impact the stochastic exploration of the marginal distribution</li>
<li>how long shall we integrate along a certain level set</li>
</ul>
<section id="choice-of-kinetic-energy" class="level3">
<h3 class="anchored" data-anchor-id="choice-of-kinetic-energy">Choice of Kinetic Energy</h3>
<p>In theory we can choose any Kinetic Energy function K(p) that we deem useful. The ideal kinetic energy would interact with the target distribution to make microcanonical exploration as easy and uniform as possible and marginal exploration well matched by the transition distribution.</p>
<p>In practice we often use</p>
<p><span class="math display">\[K(p) = p'M^{-1}p \]</span></p>
<p>so that $K(p) = _i $ and M is diagonal square matrix with elements $ 1/m_i $. This would allow us to particularize to various parameters.</p>
<p>This is a euclidean-gaussian choice: euclidean as it corresponds to a euclidean norm on the co-ordinate space and gaussian as the conditional distribution it induces is Gaussian. Gaussian choices perform well in higher dimensions as marginal energy distributions become a convolution of more and more parameters and a kind of central-limit theorem holds.</p>
<p>If one were to set the inverse mass matrix to the covariance of the target distribution then one would maximally decorrelate the target distribution. This can be seen thus: apply the transformation <span class="math inline">\(p \to \sqrt{M^{-1}}p\)</span> which simplifies the kinetic energy but transforms the potential via <span class="math inline">\(q \to \sqrt{M}q\)</span> due to the duality and volume preservation of <span class="math inline">\(q,p\)</span> phase space. Then you are effectively dividing <span class="math inline">\(q\)</span> by the squareoot of its distributions covariance and carrying out our decorrelation.</p>
<p>We can do this by computing a target covariance in a warm-up (this is not burn-in) phase of our sampler and then setting the kinetic energy appropriately to make an optimized chain.</p>
</section>
<section id="choice-of-integration-times" class="level3">
<h3 class="anchored" data-anchor-id="choice-of-integration-times">Choice of integration times</h3>
<p>Choosing a kinetic energy defines the shape of the level sets. Now the game is to glide along any one of these. How long should we do it? If we do it too short, we are not taking advantage of the coherent Hamiltonian updates and are back to our drunk random walk. If we do it too long, the topological compactness of these level sets in well defined problems will mean we revisit old points in phase space, yielding slower convergence.</p>
<p>What we need to do is to find the point at which the orbital expectations converge to the spatial expectations..a sort of ergodicity. Integrating beyond this regime brings diminishing returns.</p>
<p>This time can be represented with two parameters, <span class="math inline">\(L\)</span>, the number of iterations for which we run the Hamiltonian dynamics, and <span class="math inline">\(\epsilon\)</span> which is the (small) length of time each iteration is run. We say iterations as to solve Hamiltonian differential equations we will need to carry out a numerical solution of these equations with a small time-grid size. Then the total integration time is <span class="math inline">\(L \times \epsilon\)</span>. These are parameters we need to play with, for this and other reasons (see below).</p>
<p>But in general, no single optimal integration time will hold…this depends on which orbit in which level set we are. In general, for a distribution more heavy tailed than a Gaussian, as we move to higher energy level sets in the tails, we will need more time to integrate over there (this can be shown analytically in 1-D$). Thus if we used a static integration time everywhere, the tails might be very poorly explored (and presumably more of the typical set is in the tails of these distributuions than for thin tailed ones.</p>
<p>Thus in general we will want to identify the integration time dynamically. This is the idea behind the No U-Turn Sampler (NUTS) which is the default in both pymc3 and Stan: the basic idea is that when the Hamiltonian flows starts to double back on itself and retrace its steps, we resample momentum again.</p>
</section>
</section>
<section id="simulating-hamiltonian-systems-discretization" class="level2">
<h2 class="anchored" data-anchor-id="simulating-hamiltonian-systems-discretization">Simulating Hamiltonian Systems: Discretization</h2>
<p>Unfortunately we can’t simulate Hamiltonian systems exactly and we have to rely on discretization! What does that mean? Well in the derivations above, we assumed that we could solve the differential equations in question exactly. Since we’re going to be sampling from our Hamiltonian dynamics we need to discretize our systems in to small timesteps of size $ $.</p>
<p>There are a number of discretization methods available for simulating dynamics systems. It turns out that all of them aren’t equally useful. Some of the properties of the Let’s start with the simplest, Euler discretization. In all of our discretization examples we’ll make the following assumptions:</p>
<ul>
<li>the Hamiltonian has the form H(q, p) = U(q)+K(p)</li>
<li>K(p) = $p’M^{-1}p $ so that $K(p) = _i $ and M is square with diagonal elements $ 1/m_i $</li>
</ul>
<p>Let’s start with the most basic discretization, Euler’s method.</p>
<section id="euler-discretization" class="level3">
<h3 class="anchored" data-anchor-id="euler-discretization">Euler Discretization</h3>
<p>Euler discretization involves directly updating the momentum and position at each time step. The algorithm is as follows:</p>
<ul>
<li>$p_i(t + ) = p_i(t) - _{q(t)} $</li>
<li>$q_i(t + ) = q_i(t) + $</li>
</ul>
<p>See code and plot below for harmonic oscillator, $ H = U(q) + K(p) = + $. Notice that the volume is not preserved as the trajectory we plot for the harmonic oscillator, which should be an elipse, diverges to infinity and the Hamiltonian is not conserved as we’d expect it to be. Something is wrong with this discretization.</p>
<div id="cell-22" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> <span class="kw">lambda</span> q: q<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="kw">lambda</span> p:  (p<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>dUdq<span class="op">=</span> <span class="kw">lambda</span> q: q</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euler(p0, q0, L, epsilon):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    ps <span class="op">=</span> [p0]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    qs <span class="op">=</span> [q0]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    pprev <span class="op">=</span> p0</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    qprev <span class="op">=</span> q0</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># alternate full steps for position and momentum</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(L):</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> pprev <span class="op">-</span> epsilon<span class="op">*</span>dUdq(qprev)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        ps.append(p)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> qprev <span class="op">+</span> epsilon<span class="op">*</span>pprev</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        qs.append(q)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        pprev <span class="op">=</span> p</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        qprev <span class="op">=</span> q</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (ps, qs)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>eps,eqs <span class="op">=</span> euler(<span class="dv">1</span>,<span class="dv">0</span>, <span class="dv">55</span>, <span class="fl">.3</span>)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> [U(q) <span class="op">+</span> K(p) <span class="cf">for</span> q, p <span class="kw">in</span> <span class="bu">zip</span>(eqs, eps)]</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>[<span class="dv">12</span>,<span class="dv">8</span>])</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>plt.plot(eqs,eps, <span class="st">'b.'</span>)</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'q'</span>)</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'p'</span>)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>plt.plot(h)</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'H'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Most ODE solvers, like the one we just wrote, suffer from drift:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/nummodeerr.png" class="img-fluid figure-img"></p>
<figcaption>Numerical integration error: the exact trajectory (red) versus the leapfrog approximation (green) in a vector field. From Neal.</figcaption>
</figure>
</div>
<p>As we solve longer, error adds coherently, and our trajectory diverges from the true trajectory. This is because our discrete transformations like the Euler one above, do not preserve volume elements: the determinant of the Jacobian is larger than 1. The critical reason behind this is that we update both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> simultaneously, accumulating error fast.</p>
<p>If you think about the Jacobian, then the diagonal terms are 1. But if you update both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> at once, the off-diagonals are non-zero for small but finite <span class="math inline">\(\epsilon\)</span> (in other words u cant make <span class="math inline">\(\epsilon \to 0\)</span>). Thus volume is not preserved.</p>
<p>What we want are <strong>symplectic</strong> integrators, which preserve phase space volume elements.</p>
</section>
<section id="being-symplectic-the-leapfrog-method" class="level3">
<h3 class="anchored" data-anchor-id="being-symplectic-the-leapfrog-method">Being symplectic: the Leapfrog method</h3>
<p>Any method that has only <em>shear</em> transforms: ie something that changes only one thing at a time, will work. The <strong>leapfrog</strong> method is one such idea, involving stage-wise updating the momentum and position. The algorithm is as follows:</p>
<ul>
<li>$p_i(t + ) = p_i(t) - _{q(t)} $</li>
<li>$q_i(t + ) = q_i(t) + $</li>
<li>$p_i(t + ) = p_i(t+) - _{q(t+ )} $</li>
</ul>
<p>If we do this repeatedly, the first and last steps can be combined as you can see in the code below.</p>
<p>Notice that volume is preserved and the trajectory is very stable. In addition the discretization is reversible. The leapfrog method (named because updating momentum and position leapfrog each other) is a symplectic discretization.</p>
<div id="cell-25" class="cell" data-execution_count="27">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> <span class="kw">lambda</span> q: (q)<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="fl">2.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="kw">lambda</span> p:  (p<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="fl">2.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>dUdq<span class="op">=</span> <span class="kw">lambda</span> q: q</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> leapfrog(p0, q0, L, epsilon):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># keep all the epsilon steps</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    ps <span class="op">=</span> [p0]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    qs <span class="op">=</span> [q0]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># starting position</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> p0</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> q0</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Make a half step for momentum at the beginning</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> p <span class="op">-</span> epsilon<span class="op">*</span>dUdq(q)<span class="op">/</span><span class="fl">2.0</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># alternate full steps for position and momentum</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(L):</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> q <span class="op">+</span> epsilon<span class="op">*</span>p</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        qs.append(q)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i <span class="op">!=</span> L<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> p <span class="op">-</span> epsilon<span class="op">*</span>dUdq(q)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>            ps.append(p)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">#make a half step at the end</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> p <span class="op">-</span> epsilon<span class="op">*</span>dUdq(q)<span class="op">/</span><span class="fl">2.</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    ps.append(p)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (ps, qs)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>lps,lqs <span class="op">=</span> leapfrog(<span class="fl">4.</span>,<span class="fl">0.</span>, <span class="dv">1000</span>, <span class="fl">.1</span> )</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> [U(q) <span class="op">+</span> K(p) <span class="cf">for</span> q, p <span class="kw">in</span> <span class="bu">zip</span>(lqs, lps)]</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"min and max of leapfrog H: "</span>, np.<span class="bu">min</span>(h), np.<span class="bu">max</span>(h))</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>[<span class="dv">12</span>,<span class="dv">4</span>])</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>plt.plot(lqs,lps, <span class="st">'b.'</span>)</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>plt.plot(x_t(t), r_t(t), <span class="st">'r.'</span>)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'x(t)'</span>)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'y(t)'</span>)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>plt.plot(h)</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>min and max of leapfrog H:  7.6190477193 8.42105060531</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-7-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>One thing to note, see the diagram and code above, is that even though the discretization is symplectic it (like the Euler modification) doesn’t preserve the Hamiltonian perfectly. That’s because of the approximation errors incumbant in discretization. The error is very stable and the value of the Hamiltonian at each step oscillates around the true value.</p>
<p>Because of this exact reversibility is lost. There is no reason to sweat though, superman to the rescue! When we sample from the potential in our HMC, we will use the acceptance probability to balance out the error in H.</p>
</section>
<section id="the-acceptance-probability" class="level3">
<h3 class="anchored" data-anchor-id="the-acceptance-probability">The Acceptance Probability</h3>
<p>At the beginning of each sampling step we choose a new <span class="math inline">\(p\)</span> and our current <span class="math inline">\(q\)</span> and then run the Leapfrog algorithm for <span class="math inline">\(L\)</span> steps of size $ $. The new <span class="math inline">\(q_L\)</span> and <span class="math inline">\(p_L\)</span> at the end of our Leapfrog steps is our new proposed values, with our proposal being</p>
<p><span class="math display">\[Q(q', p' \vert q, p) = \delta(q' - q_L) \delta (p' - p_L).\]</span></p>
<p>In other words, only propose something which gives us the integration sanctioned values..deterministic!</p>
<p>This would seam to be the end of the story, but remember that even our symplectic integrator has errors. Errors make the Hamiltonian flow irreversible. In other words we can only propose states going forwards in time: the proposal probability for the time-reversed transition is 0 and the acceptance ratio undefined.</p>
<p>But we know how to make the Hamiltonian transition reversible! Superman to the rescue. We augment the numerical integration with a momentum flip so that we now consider the transition:</p>
<p><span class="math display">\[(q,p) \to (q_L, -p_L)\]</span></p>
<p>with proposal:</p>
<p><span class="math display">\[Q(q', p' \vert q, p) = \delta(q' - q_L) \delta (p' + p_L).\]</span></p>
<p>This leads us to accept with probability</p>
<p><span class="math display">\[A = \min[1, \frac{p(q_L, -p_L)\delta(q_L -q_L)\delta(-p_L + p_L)}{p(q,p)\delta(q-q)\delta(p-p)}] = \min[1, \frac{p(q_L, -p_L)}{p(q,p)}]\]</span></p>
<p>and thus:</p>
<p><span class="math display">\[A= \min[1, \exp(-U(q_L)+U(q)-K(p_L)+K(p)] \]</span></p>
<p>This is exactly the kind of acceptance ratio we have seen in simulated annealing and metropolis, and stems from our definition of the joint(canonical) distribution.</p>
<p>But the critical thing with HMC is that our <strong>time evolution is on a level set</strong>. So our acceptance probability is always close to 1, and we have a very efficient sampler. (You might have thought you could pick up a sample after each leapfrog update since it is coherent evolution of Hamiltonian equations, but then you would have to do a momentum reversal and acceptance comparision many many times).</p>
<p>The momentum reversal could be left out if you are not within a more complex sampling scheme like HMC within gibbs since you will be resampling anyways. But if you are updating both a discrete parameter and a continuous parameter, you will want to reverse the sign so that you are using the correct <span class="math inline">\(p\)</span> when sampling from the conditionals.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/reversemom.png" class="img-fluid figure-img"></p>
<figcaption>Reversibility in leapfrog integration: negating momentum at the endpoint and reintegrating returns to the starting point. From Neal.</figcaption>
</figure>
</div>
<p>In general we’ll want to sum over all such points in the orbit, since we want time averages to represent a sample from the microcanonical distribution.</p>
</section>
</section>
<section id="the-hmc-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="the-hmc-algorithm">The HMC Algorithm</h2>
<p>Now that we have the tools in place, let’s describe the HMC algorithm. We’re going to assume as above a Kinetic Energy $ K(p) = $. The algorithm is as follows</p>
<ul>
<li>for i=1:N_samples
<ol type="1">
<li>Draw $ p N(0,M) $</li>
<li>Set $ q_{c} = q^{(i)} $ where the subscript <span class="math inline">\(c\)</span> stands for current</li>
<li>$ p_c = p $</li>
<li>Update momentum before going into LeapFrog stage: $ p^* = p_c - $<br>
</li>
<li>LeapFrog to get new proposals. For j=1:L
<ul>
<li>$ q^{<em>} = q^{</em>} + p $</li>
<li>if not the last step, $ p = p - U(q) $</li>
</ul></li>
<li>Complete leapfrog: $ p = p - $</li>
<li>$ p^{*}= -p $</li>
<li>$ U_c = U(q_c), ,,, K_c = $</li>
<li>$ U^{<em>} = U(q^</em>), ,,, K^{*} = $</li>
<li>$ r \rm{Unif}(0,1) $</li>
<li>if $ r &lt; e<sup>{(U_{c}-U</sup>{<em>}+K_{c}-K^{</em>})} $<br>
* accept <span class="math inline">\(q_i = q^*\)</span> * otherwise reject</li>
</ol></li>
</ul>
<section id="a-simple-implementation" class="level3">
<h3 class="anchored" data-anchor-id="a-simple-implementation">A simple implementation</h3>
<p>We implement the HMC algorithm below with a gaussian Kinetic energy</p>
<div id="cell-31" class="cell" data-execution_count="42">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">#constants</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> HMC(U,K,dUdq,N,q_0, p_0, epsilon<span class="op">=</span><span class="fl">0.01</span>, L<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    p_mu<span class="op">=</span><span class="fl">0.</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    p_sig<span class="op">=</span><span class="fl">1.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    current_q <span class="op">=</span> q_0</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    current_p <span class="op">=</span> p_0</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> np.zeros(N)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    qall <span class="op">=</span> np.zeros(N)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    accept<span class="op">=</span><span class="dv">0</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> current_q</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> current_p</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">#draw a new p</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> np.random.normal(p_mu, p_sig)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        current_p<span class="op">=</span>p</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># leap frog</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Make a half step for momentum at the beginning</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> p <span class="op">-</span> epsilon<span class="op">*</span>dUdq(q)<span class="op">/</span><span class="fl">2.0</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># alternate full steps for position and momentum</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(L):</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>            q <span class="op">=</span> q <span class="op">+</span> epsilon<span class="op">*</span>p</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i <span class="op">!=</span> L<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>                p <span class="op">=</span> p <span class="op">-</span> epsilon<span class="op">*</span>dUdq(q)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">#make a half step at the end</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> p <span class="op">-</span> epsilon<span class="op">*</span>dUdq(q)<span class="op">/</span><span class="fl">2.</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># negate the momentum</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        p<span class="op">=</span> <span class="op">-</span>p<span class="op">;</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>        current_U <span class="op">=</span> U(current_q)</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>        current_K <span class="op">=</span> K(current_p)</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>        proposed_U <span class="op">=</span> U(q)</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>        proposed_K <span class="op">=</span> K(p)</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>        A<span class="op">=</span>np.exp( current_U<span class="op">-</span>proposed_U<span class="op">+</span>current_K<span class="op">-</span>proposed_K)</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># accept/reject</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.random.rand() <span class="op">&lt;</span> A:</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>            current_q <span class="op">=</span> q</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>            qall[j]<span class="op">=</span>q</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>            accept<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>            qall[j] <span class="op">=</span> current_q</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>        H[j] <span class="op">=</span> U(current_q)<span class="op">+</span>K(current_p)</span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"accept="</span>,accept<span class="op">/</span>np.double(N))</span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> H, qall</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-32" class="cell" data-execution_count="43">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co"># functions</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> <span class="kw">lambda</span> q: q<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="fl">2.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="kw">lambda</span> p:  (p<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="fl">2.</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>dUdq<span class="op">=</span> <span class="kw">lambda</span> q: q</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-33" class="cell" data-execution_count="45">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>H, qall<span class="op">=</span> HMC(U<span class="op">=</span>U,K<span class="op">=</span>K,dUdq<span class="op">=</span>dUdq,N<span class="op">=</span><span class="dv">10000</span>,q_0<span class="op">=</span><span class="dv">0</span>, p_0<span class="op">=-</span><span class="dv">4</span>, epsilon<span class="op">=</span><span class="fl">0.01</span>, L<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.hist(qall, bins<span class="op">=</span><span class="dv">50</span>, normed<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">100</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>plt.plot(x, sp.stats.norm.pdf(x),<span class="st">'r'</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>accept= 1.0</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-10-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We compare it to a MH sampler with the same number of steps</p>
<div id="cell-35" class="cell" data-execution_count="46">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> MH_simple(p, n, sig, x0):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    x_prev <span class="op">=</span> x0</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>[]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    k<span class="op">=</span><span class="dv">1</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    i<span class="op">=</span><span class="dv">0</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i<span class="op">&lt;</span>n:</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        x_star <span class="op">=</span> np.random.normal(x_prev, sig)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        P_star <span class="op">=</span> p(x_star)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        P_prev <span class="op">=</span> p(x_prev)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span>  np.random.uniform()</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span>  P_star<span class="op">/</span>P_prev</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> U <span class="op">&lt;</span> A:</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>            x.append(x_star)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>            x_prev <span class="op">=</span> x_star</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>            k <span class="op">+=</span><span class="dv">1</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> :</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>            x.append(x_prev)</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>            x_prev <span class="op">=</span> x[i]  </span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"accept="</span>,k<span class="op">/</span>np.double(n))</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="cell-36" class="cell" data-execution_count="47">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>samples_mh <span class="op">=</span> MH_simple(p<span class="op">=</span>P, n<span class="op">=</span><span class="dv">10000</span>, sig<span class="op">=</span><span class="fl">4.0</span>, x0<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>plt.hist(qall, bins<span class="op">=</span><span class="dv">50</span>, normed<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">100</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x, sp.stats.norm.pdf(x),<span class="st">'r'</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>plt.hist(samples_mh, bins<span class="op">=</span><span class="dv">50</span>, normed<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">100</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>plt.plot(x, sp.stats.norm.pdf(x),<span class="st">'r'</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>accept= 0.3002</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Here we see that the MH acceptance ration is much lower and the correlation much higher!</p>
<div id="cell-38" class="cell" data-scrolled="false" data-execution_count="54">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> corrplot(trace,  maxlags<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    plt.acorr(trace<span class="op">-</span>np.mean(trace),  normed<span class="op">=</span><span class="va">True</span>, maxlags<span class="op">=</span>maxlags)<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    plt.xlim([<span class="dv">0</span>, maxlags])</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>corrplot(qall)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'hmc'</span>)<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-39" class="cell" data-execution_count="55">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>corrplot(samples_mh)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'mh'</span>)<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-14-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<!-- Inject yin-yang brand icon into navbar -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Find the navbar brand
  const navbarBrand = document.querySelector('.navbar-brand');
  if (navbarBrand) {
    // Create the brand mark element
    const brandMark = document.createElement('span');
    brandMark.className = 'brand-mark';
    brandMark.innerHTML = '<i class="bi bi-yin-yang"></i>';

    // Insert at the beginning of navbar brand
    navbarBrand.insertBefore(brandMark, navbarBrand.firstChild);
  }
});
</script>
<div id="discuss-links" style="margin-top: 2.5rem; padding-top: 1.5rem; margin-bottom: 4rem; border-top: 1px solid var(--color-border, #ddd);">
  <p style="font-family: var(--font-mono, monospace); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--color-text-muted, #666); margin-bottom: 0.75rem;">Discuss this post</p>
  <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
    <a id="discuss-twitter" href="#" target="_blank" rel="noopener" style="font-size: 0.9rem;">X / Twitter</a>
    <a id="discuss-bluesky" href="#" target="_blank" rel="noopener" style="font-size: 0.9rem;">Bluesky</a>
    <a id="discuss-linkedin" href="#" target="_blank" rel="noopener" style="font-size: 0.9rem;">LinkedIn</a>
  </div>
</div>
<script>
(function() {
  var p = window.location.pathname;
  var isContent = p.startsWith("/posts/") || p.startsWith("/til/") || p.startsWith("/collections/");
  var isListing = (p === "/posts/" || p === "/posts" || p === "/til/" || p === "/til" || p === "/collections/" || p === "/collections");
  if (!isContent || isListing) {
    document.getElementById("discuss-links").style.display = "none";
    return;
  }

  var url = encodeURIComponent(window.location.href);
  var title = encodeURIComponent(document.title);

  document.getElementById("discuss-twitter").href =
    "https://twitter.com/intent/tweet?text=" + title + "&url=" + url + "&via=rahuldave";
  document.getElementById("discuss-bluesky").href =
    "https://bsky.app/intent/compose?text=" + title + " " + encodeURIComponent(window.location.href);
  document.getElementById("discuss-linkedin").href =
    "https://www.linkedin.com/sharing/share-offsite/?url=" + url;
})();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/rahuldave\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>